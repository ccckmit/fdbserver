# 第 3 章 - 函數

# JavaScript 的函數與參數

## 取大值

檔案： @[[max.js]](code/max.js)

```
function max(a,b) {
  if (a>b)
    return a;
  else
    return b;
}

m = max(9,5);
console.log("max(9,5)="+m);
```

執行結果：

```
nqu-192-168-61-142:code mac020$ node max.js
max(9,5)=9
```

在此必須說明一點，函數呼叫時，參數的傳遞與名稱無關，而是與參數的位置有關。

舉例而言，上面我們用 max(9,5) 呼叫 max 函數，此時 a, b 分別會帶入 a=9, b=5 的值進去，因此判斷式會得到 if (9>5) return 9; 於是會傳回 9.

但是如果我們用下列的呼叫方式，那麼就會得到 z=7。

```
x=3; y=7;
z = max(x,y); // 此時 x 會代入 a, y 會代入 b 於是得到 max(x,y) = max(3,7) = 7
```

假如呼叫時有 a, b 等變數，也不會因為名稱相同而代入，而是按照位置填入，舉例而言，在以下程式中，

```
a=8; b=2;
c = max(b,a); // 此時 b=2 會代入參數 a, 而 a=8 會代入參數 b 於是得到 max(b,a) = max(2,8) = 8
```

總而言之，函數是根據呼叫時的位置代入的，而非根據名字。

## 計算總和

檔案： @[[fsum.js]](code/fsum.js)

```

function sum(n) {
  s=0;
  for (i=1; i<=n; i++) {
	s = s+i;
  }
  return s;
}

sum10 = sum(10);
console.log("1+...+10="+sum10);

```

執行結果：

```
nqu-192-168-61-142:code mac020$ node fsum.js
1+...+10=55
```

## 質數測試

檔案： @[[prime.js]](code/prime.js)

```
function isPrime(n) {
  for (var i=2; i<n; i++) {
    if (n%i === 0)
      return false;
  }
  return true;
}

console.log("isPrime(33)="+isPrime(33));
console.log("isPrime(17)="+isPrime(17));

for (var p=1; p<=100; p++) {
  if (isPrime(p))
    console.log("isPrime("+p+")");
}

```

執行結果

```
nqu-192-168-61-142:code mac020$ node prime.js
isPrime(33)=false
isPrime(17)=true
isPrime(1)
isPrime(2)
isPrime(3)
isPrime(5)
isPrime(7)
isPrime(11)
isPrime(13)
isPrime(17)
isPrime(19)
isPrime(23)
isPrime(29)
isPrime(31)
isPrime(37)
isPrime(41)
isPrime(43)
isPrime(47)
isPrime(53)
isPrime(59)
isPrime(61)
isPrime(67)
isPrime(71)
isPrime(73)
isPrime(79)
isPrime(83)
isPrime(89)
isPrime(97)
nqu-192-168-61-142:code mac020$ 

```

# 亂數

檔案： @[[random.js]](code/random.js)

```
function randBetween(a,b) {
  return a+Math.random()*(b-a);
}

function randInt(a,b) {
  return Math.floor(randBetween(a,b));
}

function repeats(n, f) {
  var a = [];
  for (var i=0; i<n; i++) {
    a.push(f());
  }
  return a;
}

var rList = repeats(10, function() {
  var r=randInt(0,2);
  console.log("r="+r);
  return r;
});

console.log("rList=%j", rList);
```

執行結果

```
D:\Dropbox\cccweb\db\js\code>node random.js
r=1
r=1
r=1
r=0
r=1
r=0
r=0
r=1
r=0
r=0
rList=[1,1,1,0,1,0,0,1,0,0]

```

# 亂數2

## 系統亂數 : Math.random()

```
NQU-192-168-60-101:ccc csienqu$ node
> (1+(1))-((7))
-5
> ((1/(((3+(7)-(4-1)/9*8/7-6)/(4)-3+3)-6-9*(((2+(((6*4/4)))*(8/3))))-9-0-1+5*8*((5)/(3)-1/(1)-9)+(5+5*5))))*5/2
-0.005203687184061849
> Math.random()
0.6770120605360717
> Math.random()
0.42311601690016687
> Math.random()
0.8769011830445379
> Math.random()
0.48077693535014987
> Math.random()
0.5951373421121389
> Math.random()
0.2052019238471985
```

## 取 (a,b) 範圍間的亂數 (浮點數版 -- rand)

```
> function rand(a,b) { return a+Math.random*(b-a); }
undefined
> rand(1,10)
NaN
> function rand(a,b) { return a+Math.random()*(b-a); }
undefined
> rand(1,10)
9.309291471494362
> rand(1,10)
3.008262322982773
> rand(1,10)
3.473059037467465
```

## 取 (a,b) 範圍間的亂數 (整數版 -- randInt)

```
> function randInt(a,b) { return Math.floor(a+Math.random()*(b-a)); }
undefined
> randInt(1,10)
4
> randInt(1,10)
5
> 
> randInt(1,10)
7
> randInt(1,10)
2
> randInt(1,10)
2
> randInt(1,10)
8
> randInt(1,10)
3
> randInt(1,10)
1
>
```

## 從陣列中隨機選擇一個元素 randSelect(a)

```
 > function randSelect(a) { return a[randInt(0,a.length)]; }
undefined
> randSelect([1,7,4])
1
> randSelect([1,7,4])
1
> randSelect([1,7,4])
4
> randSelect([1,7,4])
7
> randSelect([1,7,4])
7
> function randSelect(a) { return a[randInt(0,a.length)]; }
undefined
> randSelect([1,7,4])
4
> randSelect(['a','g','c'])
'a'
> randSelect(['a','g','c'])
'c'
> randSelect(['a','g','c'])
'a'
> randSelect(['a','g','c'])
'g'
> randSelect(['a','g','c'])
'g'
> randSelect(['a','g','c'])
'g'
> randSelect(['dog','cat'])
'cat'
> randSelect(['dog','cat'])
'dog'
> randSelect(['dog','cat'])
'cat'
> randSelect(['dog','cat'])
'cat'
> randSelect(['dog','cat'])
'dog'
> randSelect(['dog','cat'])
'cat'
```



# 匿名函數與回呼

## 函數的宣告

在 JavaScript 當中，函數的宣告方法大致有兩種，第一種的宣告方法就和一般程式語言 (C/C++, Python, Java) 等差不多，是採用 f(a,b,c...) 這種方式宣告的，但是必須在前面加上 function 這個關鍵字。

在以下範例中， sub(a,b) 就是採用這種方式宣告的一個範例。

檔案：function.js

```javascript
// 第一種寫法，直接宣告函數
function sub(a,b) {         
  return a-b;
}

// 第二種寫法，將匿名函數指定給變數。
var add = function(a,b) {     
  return a+b;
}
console.log("add(3,5)=", add(3,5), " sub(7,2)=", sub(7,2));
```

執行結果：

```
D:\js\code>node function.js
add(3,5)= 8  sub(7,2)= 5
```

但是、在 JavaScript 當中，還有一種比較特別函數宣告方式，是在宣告了一個「匿名函數」之後，再把這個函數「塞給」一個變數。就像上述的 `var add = function(a,b) ...` 的做法，這樣我們就可以用 add(3,5) 這樣的方式去呼叫該函數了。

## 參數的傳遞

有些人說，javascript 傳遞參數都是採用傳值的方式，這種說法雖然不能說錯，但必須注意一件事。

對於基礎型態，像是數值、布林值等等，是採用傳值的方式，也就是複製一份之後再傳給函數，但是對於像陣列、物件、字串等等，雖然也是複製一份傳給函數，但是複製的卻是其指標，因此對於這些復合結構的物件而言，說白了就是採用傳參照的方式。

參考： <http://heyyou.logdown.com/posts/145054>

## 函數型態的參數

在上面的 add 範例中，我們將「函數」塞給一個變數，而且還可以直接把該變數當作函數來呼叫。

那麼、我們能不能將函數當作參數來傳遞呢？ 

關於這點、當然是可以的，以下是一個將「函數當作參數」的範例。

檔案： fptr

```javascript
function sub(a,b) {         
  return a-b;
}

function f5(f, a) {
  return f(a, 5);
}

console.log("sub(8,5)="+sub(8, 5));
console.log("f5(sub,8)="+f5(sub,8));
```

執行結果

```
D:\Dropbox\Public\web\js\code>node fptr
sub(8,5)=3
f5(sub,8)=3
```

您可以看到，函數 `f5(f, a)` 的參數 f，其實又是一個函數，因為我們在 f(a,5) 當中把 f 當作函數來呼叫。

所以、當我們呼叫 f5(sub, 8) 的時候，該函數會傳回 3，因為當我們將 f5(sub, 8) 內容中的 f 取代為 sub，而 a 取代為 8 時，就會發現 return 語句的 f(a,5) 其實就是 sub(8,5)，所以當然就會傳回 3 囉！

## 呼叫不特定函數

既然可以將函數當成參數傳入，那麼我們就可以設計一個如下的 run 函數，該函數在執行完待呼叫函數 f 之後，再把執行結果印出來。

檔案： @[[run.js]](code/run.js)

```
function run(f, x) {
  var fx = f(x);
  console.log("f(x)="+fx);
}

run(Math.sin, Math.PI/4);
```

執行結果

```
D:\Dropbox\cccweb\db\js\code>node run.js
f(x)=0.7071067811865475
```

## 套用函數在陣列中的每個元素上

透過將函數傳入的方式，我們也可以設計出處理陣列中每個元素的高階函數，舉例而言，以下的 each 函數就是一個範例。

檔案： @[[each.js]](code/each.js)

```
function each(a, f) {
  for (var i in a) {
    f(a[i]);
  }
}

each([3,4,5,6], console.log);

function sinPrint(x) {
  console.log("sin(%d)=%d", x, Math.sin(x));
}

each([3,4,5,6], sinPrint);
```

執行結果

```
D:\Dropbox\cccweb\db\js\code>node each.js
3
4
5
6
sin(3)=0.1411200080598672
sin(4)=-0.7568024953079282
sin(5)=-0.9589242746631385
sin(6)=-0.27941549819892586
```

我們也可以設計出如下的 map 函數將整個陣列套用函數後轉換成另一個陣列。

檔案： @[[map.js]](code/map.js)

```
var c = console;

function map(f, a) {
  var ma = [];
  for (var i in a) {
    ma.push(f(a[i]));
  }
  return ma;
}

function square(x) {
  return x*x;
}

c.log("map(x^2, [3, 1, 5, 4, 2])="+map(square, [3,1,5,4,2]));
c.log("map(sin(x), [3, 1, 5, 4, 2])="+map(Math.sin, [3,1,5,4,2]));
```

執行結果

```
D:\Dropbox\cccweb\db\js\code>node map.js
map(x^2, [3, 1, 5, 4, 2])=9,1,25,16,4
map(sin(x), [3, 1, 5, 4, 2])=0.1411200080598672,0.8414709848078965,-0.9589242746
631385,-0.7568024953079282,0.9092974268256817
```

## 回呼 (callback)

既然可以將函數當成參數傳入，那麼我們就可以將某個函數傳入，等到某些動作執行完成之後再呼叫該函數，這種方法就稱為回呼 Callback 。

在 node.js 或網頁中，我們常常需要在輸出入動作完成後進行回呼，或者是在某些適當的時機去執行某些函數，這些都可以採用上述的回呼技術來設計。


# 微分

檔案： @[[df.js]](code/df.js)

```
function df(f, x) {
  var dx = 0.001;
  var dy = f(x+dx) - f(x);
  return dy/dx;
}

function square(x) {
  return x*x;
}

console.log('df(x^2,2)='+df(square, 2));
console.log('df(x^2,2)='+df(function(x){ return x*x; }, 2));
console.log('df(sin(x/4),pi/4)='+df(Math.sin, 3.14159/4));
```

執行結果

```
D:\Dropbox\cccweb\db\js\code>node df.js
df(x^2,2)=4.000999999999699
df(x^2,2)=4.000999999999699
df(sin(x/4),pi/4)=0.7067535793015001
```

# 積分

檔案： @[[integral.js]](code/integral.js)

```
function integral(f, a, b) {
  var dx = 0.001;
  var area = 0.0;
  for (var x=a; x<b; x=x+dx) {
    area = area + f(x)*dx;
  }
  return area;
}

function square(x) {
  return x*x;
}

console.log('integral(x^2,0,1)='+integral(square,0,1));
console.log('integral(sin(x),0,pi)='+integral(Math.sin,0,3.14159));
```

執行結果

```
D:\Dropbox\cccweb\db\js\code>node integral.js
integral(x^2,0,1)=0.33283350000000095
integral(sin(x),0,pi)=1.9999999540411524
```

