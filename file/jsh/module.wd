# 第 6 章 - 模組

### 使用他人的模組

# 用 npm 安裝外部套件

使用 npm install 可以安裝套件，舉例而言，假如我們有一個程式 main.js 用到 lodash 套件，其原始碼如下：

檔案： main.js

```javascript
var _=require("lodash");

var set=_.intersection([1,3,7,9], [2,3,8,9]);
console.log("set=", set);
```

我們想要執行這個程式，於是切到 main.js 所在的資料夾後打入 node main.js ，結果卻發現下列情況。

```
nqu-192-168-61-142:package mac020$ ls
main.js
nqu-192-168-61-142:package mac020$ node main.js
module.js:338
    throw err;
    ^

Error: Cannot find module 'lodash'
    at Function.Module._resolveFilename (module.js:336:15)
    at Function.Module._load (module.js:286:25)
    at Module.require (module.js:365:17)
    at require (module.js:384:17)
    at Object.<anonymous> (/Users/mac020/Dropbox/cccwd/db/js1/code/package/main.js:1:69)
    at Module._compile (module.js:434:26)
    at Object.Module._extensions..js (module.js:452:10)
    at Module.load (module.js:355:32)
    at Function.Module._load (module.js:310:12)
    at Function.Module.runMain (module.js:475:10)

```

這代表我們沒有安裝 lodash 套件，因此我們必須要用下列 npm 指令先安裝 lodash 套件。

```
nqu-192-168-61-142:package mac020$ npm install lodash
lodash@4.6.1 node_modules/lodash

nqu-192-168-61-142:package mac020$ ls
main.js		node_modules

nqu-192-168-61-142:package mac020$ ls node_modules
lodash
```

這樣就安裝好該套件了，您可以用 ls 列出目前資料夾內容，會發現多出的一個 node_modules 的資料夾，裡面會有 lodash 子資料夾，這代表您已經安裝好了該套件。

接著我們就可以用 node main.js 指令執行原本的程式，這樣就不會再產生錯誤了！

``` 
nqu-192-168-61-142:package mac020$ node main.js
set= [ 3, 9 ]
```

以上就是在 node.js 裏用 npm 安裝外部套件的做法！

### 設計自己的模組

## 模組定義與引用

當您用 javascript 寫出物件或函式庫時，可以提供給其他程式使用。

在 node.js 當中，模組的定義大致有兩種類型，一種是「匯出物件」的靜態模組，另一種是匯出「建構函數」的動態模組。

### 靜態模組：匯出物件

以下是一個匯出物件的靜態模組定義。

模組定義：math.js

```javascript
var math = {
    PI:3.14,
    square:function(n) {
        return n*n;
    }
}

module.exports = math;

```

接著您可以使用 require 這個指令動態的引入該模組，注意 require 必須採用相對路徑，即使在同一個資料夾底下，也要加上 ./ 的前置符號，代表在目前資料夾之下。以下是一個引用上述模組的範例。

模組使用：mathTest.js

```javascript
var m=require("./math");

console.log("PI=%d square(3)=%d", m.PI, m.square(3));
```

執行結果：

```
D:\Dropbox\Public\pmag\201306\code>node mathTest
PI=3.14 square(3)=9

```

### 動態模組：匯出建構函數

以下是一個定義圓形 circle 的物件。

模組定義：circle.js

```javascript
var PI = 3.14;
Circle = function (radius) {
    this.radius = radius
    this.area = function() {
        return PI * this.radius * this.radius;
    }
};

module.exports = Circle;
module.exports.PI = PI;

```

在引用「匯出建構函數」的程式當中，由於取得的是建構函數，因此必須再使用 new 的方式建立物件之後才能使用 
(例如以下的 `c = new cir(5)` 這個指令，就是在透過建構函數 `cir()` 建立物件。

模組使用：CircleTest.js

```javascript
var cir = require('./circle');  			// 注意，./ 代表 circle 與此程式放在同一個資料夾底下。
var c = new cir(5);
console.log("cir.PI="+cir.PI);
console.log("c.PI="+c.PI);
console.log("c.area()="+c.area());

```

執行結果

```
D:\code\node>node circleTest.js
cir.PI=3.14
c.PI=undefined
c.area()=78.5
```

您現在應該可以理解為何我們要將 Circle 定義為一個函數了吧！這只不過 Circle 類別的建構函數而已，
當他被 module.exports = Circle 這個指令匯出時，就可以在 var cir = require('./circle') 這個指令
接收到建構函數，然後再利用像 `var c = new cir(5)` 這樣的指令，呼叫該建構函數，以建立出物件。

然後，您也應該可以看懂為何我們要用 module.exports.PI = PI 將 PI 獨立塞到 module.exports 裏了吧！
因為只有這樣才能讓外面的模組在不執行物件建構函數 (不建立物件) 的情況之下就能存取 PI。

### 跨平台模組：定義各種平台均能使用的 JavaScript 模組

在很多開放原始碼的 JavaScript 專案模組中，我們會看到模組的最後有一段很複雜的匯出動作。舉例而言，
在 marked.js 這個將 Markdown 語法轉為 HTML 的模組最後，我們看到了下列這段感覺匪夷所思的匯出橋段，
這種寫法其實只是為了要讓這個模組能夠順利的在「瀏覽器、node.js、CommonJS 與其 Asynchronous 
Module Definition (AMD) 實作版的 RequireJS」等平台當中都能順利的使用這個模組而寫的程式碼而已。

```javascript

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());
```

對這個超複雜匯出程式有興趣的朋友可以看看以下的文章，應該就可以大致理解這種寫法的來龍去脈了。

* <http://www.angrycoding.com/2012/10/cross-platform-wrapper-function-for.html>

# package.json 自動套件安裝指引檔

## 簡介

使用 npm install 可以安裝套件，舉例而言，假如我們有一個程式 main.js 用到 lodash 套件，其原始碼如下：

檔案： main.js

```javascript
var _=require("lodash");

var set=_.intersection([1,3,7,9], [2,3,8,9]);
console.log("set=", set);
```

我們想要執行這個程式，於是切到 main.js 所在的資料夾後打入 node main.js ，結果卻發現下列情況。

```
nqu-192-168-61-142:package mac020$ ls
main.js
nqu-192-168-61-142:package mac020$ node main.js
module.js:338
    throw err;
    ^

Error: Cannot find module 'lodash'
    at Function.Module._resolveFilename (module.js:336:15)
    at Function.Module._load (module.js:286:25)
    at Module.require (module.js:365:17)
    at require (module.js:384:17)
    at Object.<anonymous> (/Users/mac020/Dropbox/cccwd/db/js1/code/package/main.js:1:69)
    at Module._compile (module.js:434:26)
    at Object.Module._extensions..js (module.js:452:10)
    at Module.load (module.js:355:32)
    at Function.Module._load (module.js:310:12)
    at Function.Module.runMain (module.js:475:10)

```

這代表我們沒有安裝 lodash 套件，因此我們必須要用下列 npm 指令先安裝 lodash 套件。

```
nqu-192-168-61-142:package mac020$ npm install lodash
lodash@4.6.1 node_modules/lodash

nqu-192-168-61-142:package mac020$ ls
main.js		node_modules

nqu-192-168-61-142:package mac020$ ls node_modules
lodash
```

這樣就安裝好該套件了，您可以用 ls 列出目前資料夾內容，會發現多出的一個 node_modules 的資料夾，裡面會有 lodash 子資料夾，這代表您已經安裝好了該套件。

接著我們就可以用 node main.js 指令執行原本的程式，這樣就不會再產生錯誤了！

``` 
nqu-192-168-61-142:package mac020$ node main.js
set= [ 3, 9 ]
```

## 參考文獻
* [Node.js 很好用的 package.json](http://cire.pixnet.net/blog/post/36601110-%5Bnode.js%5D%E5%BE%88%E5%A5%BD%E7%94%A8%E7%9A%84package.json)
* [NodeJS 應用佈建快手：利用 package.json 處理麻煩的模組相依性](http://fred-zone.blogspot.tw/2012/02/nodejs-packagejson.html)

### 將模組發佈到 npm 套件庫中給他人使用

# 用十分鐘瞭解JavaScript的模組 -- 《還有關於npm套件管理的那些事情》

<center>
<iframe src="//www.slideshare.net/slideshow/embed_code/key/5khMutwvWlmLfC" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/ccckmit/javascript-npm" title="用十分鐘瞭解JavaScript的模組 -- 《還有關於npm套件管理的那些事情》" target="_blank">用十分鐘瞭解JavaScript的模組 -- 《還有關於npm套件管理的那些事情》</a> </strong> from <strong><a target="_blank" href="//www.slideshare.net/ccckmit">鍾誠 陳鍾誠</a></strong> </div>
</center>

檔案： @[[hello.js]](code/jslab/hello.js)

```javascript
console.log("Hello, 你好！");
```

檔案： @[[numeric_test.js]](code/jslab/numeric_test.js)

```javascript
var numeric = require("numeric");

function print(name, m) {
  console.log("===================="+name+"=======================");
  console.log(numeric.prettyPrint(m));
}

var A = [[1,2,3],[3,2,2],[4,3,5]];
print("A", A);

var iA = numeric.inv(A);
print("iA", iA);

var AiA = numeric.dot(A, iA);
print("A*iA", AiA);
```

檔案： [[jslab.js]](code/jslab/jslab.js)

```javascript
var N = require("numeric");

var jslab = {
	inv:N.inv,
	dot:N.dot,
	str:N.prettyPrint
}

module.exports = jslab;
```

檔案： [[jslab_test.js]](code/jslab/jslab_test.js)

```javascript
var J = require("./jslab");
var C = console;

var A = [[1,2,3],[3,2,2],[4,3,5]];
C.log("A=\n", J.str(A));

var iA = J.inv(A);
C.log("iA=\n", J.str(iA));

var AiA = J.dot(A, iA);
C.log("A*iA=\n", J.str(AiA));
```

檔案： [[package.json]](code/jslab/package.json)

```javascript

  "name": "jslab",
  "version": "0.0.2",
  "description": "A Scientific Computing Library like R and Matlab",
  "main": "jslab.js",
  "dependencies": {
    "numeric": "^1.2.6"
  },
  "devDependencies": {},
  "scripts": {
    "test": "jslab_test"
  },
  "repository": {
    "type": "git",
    "url": "http://ccckmit.github.com/jslab"
  },
  "keywords": [
    "R",
    "Matlab",
    "Matrix",
    "Statistics"
  ],
  "author": {
    "name": "ccckmit",
    "email": "ccckmit@gmail.com",
    "url": "http://ccc.nqu.edu.tw"
  },
  "license": "ISC",
  "_id": "jslab@0.0.2",
  "_shasum": "ac8686ec431d535adce5bc9a9e01f815a987ecc9",
  "_from": "jslab@*",
  "_npmVersion": "3.8.2",
  "_nodeVersion": "5.1.0",
  "_npmUser": {
    "name": "ccckmit",
    "email": "ccckmit@gmail.com"
  },
  "dist": {
    "shasum": "ac8686ec431d535adce5bc9a9e01f815a987ecc9",
    "tarball": "http://registry.npmjs.org/jslab/-/jslab-0.0.2.tgz"
  },
  "maintainers": [
    {
      "name": "ccckmit",
      "email": "ccckmit@gmail.com"
    }
  ],
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/jslab-0.0.2.tgz_1459225384494_0.6699129303451627"
  },
  "directories": {},
  "_resolved": "https://registry.npmjs.org/jslab/-/jslab-0.0.2.tgz"
}

```

檔案：  @[[README.md]](code/jslab/README.md)

## 參考文獻

* [How to publish packages to NPM](https://gist.github.com/coolaj86/1318304)


