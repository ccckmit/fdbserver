# 第 4 章 - 陣列與字串

## 陣列操作

參考：  [《JavaScript 标准参考教程（alpha）》 - Array 对象](http://javascript.ruanyifeng.com/stdlib/array.html)

### 存取

```
> a=[0,1,2]
[ 0, 1, 2 ]
> a
[ 0, 1, 2 ]
> a[0]
0
> a[1]
1
> a[2]
2
> a[3]
undefined
> a[4]
undefined
> a[9]
undefined
> a[9]=9
9
> a
[ 0, 1, 2, , , , , , , 9 ]
> a[0]=7
7
> a
[ 7, 1, 2, , , , , , , 9 ]
> 

```

### 函數操作

```
> a = [1,2,3]
[ 1, 2, 3 ]
> a.push(4)
4
> a
[ 1, 2, 3, 4 ]
> a.push(5)
5
> a
[ 1, 2, 3, 4, 5 ]
> a.concat([6,7,8])
[ 1, 2, 3, 4, 5, 6, 7, 8 ]
> a
[ 1, 2, 3, 4, 5 ]
> b=a.concat([6,7,8])
[ 1, 2, 3, 4, 5, 6, 7, 8 ]
> b
[ 1, 2, 3, 4, 5, 6, 7, 8 ]
> a
[ 1, 2, 3, 4, 5 ]
> a.join()
'1,2,3,4,5'
> a.join(':')
'1:2:3:4:5'
> a.pop
[Function: pop]
> a.pop()
5
> a
[ 1, 2, 3, 4 ]
> a.reverse()
[ 4, 3, 2, 1 ]
> a
[ 4, 3, 2, 1 ]
> a.shift()
4
> a
[ 3, 2, 1 ]
> b
[ 1, 2, 3, 4, 5, 6, 7, 8 ]
> b.slice(2,4)
[ 3, 4 ]
> b.slice(2,6)
[ 3, 4, 5, 6 ]
> a
[ 3, 2, 1 ]
> a.sort()
[ 1, 2, 3 ]
> a
[ 1, 2, 3 ]
> b
[ 1, 2, 3, 4, 5, 6, 7, 8 ]
> r=b.splice(1,3, "a", "b", "c", "d")
[ 2, 3, 4 ]
> r
[ 2, 3, 4 ]
> b
[ 1, 'a', 'b', 'c', 'd', 5, 6, 7, 8 ]
> 

```

## 字串

### 字串操作

```
> x = "hello"
'hello'
> x.length
5
> x[3]
'l'
> x[2]
'l'
> x[1]
'e'
> x[0]
'h'
> x[5]
undefined
> x[4]
'o'
> x=x+" world"
'hello world'
> x
'hello world'
>
```

### 字串函數

```
> x = "0123456789"
'0123456789'
> x.substr(3,2)
'34'
> x.substr(4,5)
'45678'
> x.substring(3,7)
'3456'
> x.substring(3,9)
'345678'
> x.substring(3,10)
'3456789'
> x.length
10
> s = "abCDEfg"
'abCDEfg'
> s.toUpperCase()
'ABCDEFG'
> s.toLowerCase()
'abcdefg'
> y = "     abc      "
'     abc      '
> y.trim()
'abc'
> s.concat(y)
'abCDEfg     abc      '
> s.charAt(5)
'f'
> s.charCodeAt(5)
102
> s.charCodeAt(0)
97
> s.charAt(0)
'a'
> s.slice(3)
'DEfg'
```

## 陣列

JavaScript 的陣列宣告非常簡單，就是用 `[...]` 所框起來的一連串資料，或者您也可以用 `new Array()` 語句來建立一個空的陣列，而且可以用 length 屬性來取得陣列大小。

檔案：array.js

```javascript
var a=[1,6,2,5,3,6,1];

for (i=0;i<a.length;i++) {
  console.log("a[%d]=%d", i, a[i]);
}
```

執行結果

```
D:\jsbook>node array.js
a[0]=1
a[1]=6
a[2]=2
a[3]=5
a[4]=3
a[5]=6
a[6]=1
```

當然、javascript 有些語法是 C 語言所沒有的，像是 JavaScript 的 foreach 語句採用 `for (i in c)` 這樣的語法，其中的 c 必須是個陣列或容器，而 i 則是索引值 (注意、不是內容，是索引值)，以下是這種語句的一個範例。

檔案：foreach.js

```javascript
var a=[1,6,2,5,3,6,1];

for (i in a) {
  console.log("a[%d]=%d", i, a[i]);
}
```

執行結果

```
D:\jsbook>node foreach
a[0]=1
a[1]=6
a[2]=2
a[3]=5
a[4]=3
a[5]=6
a[6]=1
```

接著、請讀者可以思考並嘗試一下，如何撰寫下列的兩個程式。

習題 1：請寫一個程式可以將兩個陣列 a=[1,2,3] b=[3,2,1] 相加。

習題 2：請寫一個程式可以計算兩個向量 a=[1,2,3] b=[3,2,1] 的內積。


## 二維陣列

當然、我們也可以宣告二維、三維、甚至更高維的陣列，以下是一個將二為陣列格式化為字串後印出來的範例。

檔案：array2D.js

```javascript
var a=[[1,6,2],
       [5,3,6]];

for (var i=0; i<a.length; i++) {
  var line = "";
  for (var j=0; j<a[i].length; j++) {
    line = line + a[i][j] + " ";
  }
  console.log(line);
}
```

執行結果

```
D:\jsbook>node array2D
1 6 2
5 3 6
```

看了上述範例之後，也建議讀者可以嘗試一下撰寫下列程式。

習題 1：請寫一個程式可以將兩個矩陣 a=[[1,2,3], [2,3,4]] b=[[1,2,3],[1,2,3]] 相加。

習題 2：請寫一個程式可以將兩個矩陣 a=[[1,2,3], [2,3,4]] bt=[[1,1],[2,2],[3,3]] 相乘 (內積)。

# 向量 （數值陣列）

## 向量相加的標準寫法

在習題中我們已經寫過兩個向量的加法，其程式碼與執行結果如下：

檔案： @[[add.js]](code/add.js)

```
a=[1,2,3]
b=[2,2,2]

function add(x,y) {
  var r=[];
  for (var i=0; i<x.length; i++)
    r[i] = x[i]+y[i];
  return r;
}

c=add(a,b);

console.log("a="+a);
console.log("b="+b);
console.log("c="+c);
```

執行結果

```
nqu-192-168-61-142:code mac020$ node add.js
a=1,2,3
b=2,2,2
c=3,4,5
```

## 向量相加的函數變數 vadd

上述結果乃是用標準函數的寫法，假如我們採用『將函數塞入到變數中』的寫法，可以改寫如下：

```
a=[1,2,3]
b=[2,2,2]

function add(x,y) {
  var r=[];
  for (var i=0; i<x.length; i++)
    r[i] = x[i]+y[i];
  return r;
}

var vadd = add;

c=add(a,b);
d=vadd(a,b);

console.log("a="+a);
console.log("b="+b);
console.log("c="+c);
console.log("d="+d);
```

您可以看到其中的 vadd 變數其實就是 add 函數，因此呼叫的方法也都一模一樣，其執行結果如下：

```
nqu-192-168-61-142:code mac020$ node add2.js
a=1,2,3
b=2,2,2
c=3,4,5
d=3,4,5
```

## 向量相加的匿名函數寫法

假如我們採用匿名函數的寫法，然後塞給某變數之後再執行，那麼程式將可改寫如下：

```
a=[1,2,3]
b=[2,2,2]

var vadd = function(x,y) {
  var r=[];
  for (var i=0; i<x.length; i++)
    r[i] = x[i]+y[i];
  return r;
}

d=vadd(a,b);

console.log("a="+a);
console.log("b="+b);
console.log("d="+d);
```

執行結果

```
nqu-192-168-61-142:code mac020$ node add3.js
a=1,2,3
b=2,2,2
d=3,4,5

```

## 向量的物件寫法 1

```
a=[1,2,3]
b=[2,2,2]

var Vector={};

Vector.add = function(x,y) {
  var r=[];
  for (var i=0; i<x.length; i++)
    r[i] = x[i]+y[i];
  return r;
}

d=Vector.add(a,b);

console.log("a="+a);
console.log("b="+b);
console.log("d="+d);
``` 

執行結果

```
nqu-192-168-61-142:code mac020$ node vector1.js
a=1,2,3
b=2,2,2
d=3,4,5

```

您可以看到執行結果大致是相同的，只是我們將函數 add 放入了物件 vector 當中而已。

## 向量的物件寫法 2

但是如果我們試圖將 x 參數直接包入 vector 物件中，那麼會怎麼樣呢？

關於這點，牽涉到物件導向的寫法，我們將於後面探討物件導向時再來說明！


# 矩陣運算(函數版 1)

檔案:  @[[matrix.js]](code/matrix.js)

```javascript
function transpose(a){
    var r = [];
    for(var j = 0; j < a[0].length; j++){
        r[j] = [];
        for(var i = 0; i < a.length; i++){
            r[j][i] = a[i][j];
        }
    }

    return r;
}

function add(a,b){
    var r = [];
    for(var i = 0; i < a.length; i++){
        r[i] = [];
        for(var j = 0; j < a[i].length; j++){
            r[i][j] = a[i][j] + b[i][j];
        }
    }
    return r;
}

function times(a, b){
    var r = [];
    for(var i = 0; i < a.length; i++){
        r[i] = [];
        for(var j = 0; j < b[0].length; j++){
            r[i][j] = 0;
            for(var k = 0; k < a[i].length; k++){
                r[i][j] = r[i][j] + a[i][k] * b[k][j];
            }
        }
    }
    return r;
} 

var a = [[3,2,1],[1,2,3]];
var b = transpose(a);
var c = add(a,a);
var d = times(a,b);

console.log("a = %j", a);
console.log("b = %j", b);
console.log("c = %j", c);
console.log("d = %j", d);
```

## 執行結果

```
D:\git\matrix>node matrix
a = [[3,2,1],[1,2,3]]
b = [[3,1],[2,2],[1,3]]
c = [[6,4,2],[2,4,6]]
d = [[14,10],[10,14]]
```

# 矩陣運算(函數版 2)

檔案:  @[[matrix2.js]](code/matrix2.js)

```javascript
var transpose = function(a){
	var r = [];
	for(var j = 0; j < a[0].length; j++){
		r[j] = [];
		for(var i = 0; i < a.length; i++){
			r[j][i] = a[i][j];
		}
	}

	return r;
}

var add = function(a,b){
	var r = [];
	for(var i = 0; i < a.length; i++){
		r[i] = [];
		for(var j = 0; j < a[i].length; j++){
			r[i][j] = a[i][j] + b[i][j];
		}
	}
	return r;
}

var times = function(a, b){
	var r = [];
	for(var i = 0; i < a.length; i++){
		r[i] = [];
		for(var j = 0; j < b[0].length; j++){
			r[i][j] = 0;
			for(var k = 0; k < a[i].length; k++){
				r[i][j] = r[i][j] + a[i][k] * b[k][j];
			}
		}
	}
	return r;
} 

var a = [[3,2,1],[1,2,3]];
var b = transpose(a);
var c = add(a,a);
var d = times(a,b);

console.log("a = %j", a);
console.log("b = %j", b);
console.log("c = %j", c);
console.log("d = %j", d);


```

## 執行結果

```
D:\git\matrix>node matrix
a = [[3,2,1],[1,2,3]]
b = [[3,1],[2,2],[1,3]]
c = [[6,4,2],[2,4,6]]
d = [[14,10],[10,14]]
```

# 泡沫排序法

檔案: @[[bobbleSort.js]](code/bobbleSort.js)

```
function bobbleSort(a) {
  for (var i=0; i<a.length; i++) {
    for (var j=0; j<i; j++) {
      if (a[i]<a[j]) {
        var t=a[i];
        a[i] = a[j];
        a[j] = t;
      }
    }
  }
}

var x = [ 3, 9, 2, 7, 1, 8, 5, 6];

console.log("x=%j", x);

bobbleSort(x);

console.log("x=%j", x);
```

執行結果

```
D:\Dropbox\cccweb\db\js\code>node bobbleSort.js
x=[3,9,2,7,1,8,5,6]
x=[1,2,3,5,6,7,8,9]
```

